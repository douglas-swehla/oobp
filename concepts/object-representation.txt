:: object representation

Different languages represent objects in different ways.
They are (almost?) universally represented in memory, but may or may not be a contiguous series of bytes.
    Values may be in a pre-defined order, so that each value is interpreted based on its position.
    Values may be prefixed by their type, length, or other descriptive information.
    Values may be references to other objects whose actual values are stored elsewhere in memory.
Similarly, object references may be a memory address or an ID generated by the compiler or interpreter, but are usually an integer of some sort.

Batch scripts have no direct way to interact with memory; that is all handled by Windows via the CMD.exe shell and the various executable files (exe, dll) called by the script. The only memory access is by variable=value assignment. The file system can serve as an analog to the memory space, and this provides some interesting and flexible options, but requires a great many read/write file operations, which are costly in terms of time. Batch files are not expected to be fast, but it's nice to do what we can in terms of speed.

property vs method
memory vs file system
single item vs collection
method: batch vs sub vs macro

Options for batch-style objects:
    Attributes/Properties/Variables
    store in memory as individual variable=value combinations, using text prefix to variable name &/or environment locality to define namespace.
        set myObject.obj1.length=10 & set myObject.obj1.height=20
            allows fastest retrieval. but provides least privacy
        alt, use generated ID: set 48721.length=10 & set 48721.height=20
            allows slightly more privacy, through obscurity. Can use None, Nothing, Null, Empty, etc. to mimic declared but uninitialized variables. Allows atomic updates to variables; can do one at a time, as needed, with simple SET command.
    store in memory as single string of delimited, any-order variable=value combinations. Requires special handling for values that contain delimiter character. Updating one value requires recompiling string, so must touch all sibling variables, unless we take Python approach ().
        set myObject.obj1=length=10;height=20
        set obj1=class=myObject;length=10;height=20
            more privacy/encapsulation, requires additional parsing, still fairly flexible, allows for genuine null/uninitialized values.
        alt, use generated ID: set 48721=class=myObject;name=obj1;length=10;height=20
    store in memory as single string of fixed-order, delimited values.
        set myObject.obj1=10;20
        set obj1=myObject;10;20
            more privacy/encapsulation, requires additional parsing, but maybe less than others. Shorter string is less overall memory usage.
        alt, use generated ID: set 48721=myObject;obj1;10;20
    store in memory as single string of fixed-order, fixed-length values.
        set "myObject.obj1=00000000000100000000000020"
        set "obj1=myObject                                00000000000100000000000020"
        set 48721=myObject                                obj1                                    00000000000100000000000020"
            Solves delimiter problem at expense of heavy memory usage. Also requires defining default and maximum field sizes for everything.
    --Repeat above, using files--
    store variable=value in text file